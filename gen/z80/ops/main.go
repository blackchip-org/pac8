package main

//go:generate go run main.go
//go:generate go fmt ../../../cpu/z80/ops.go

// http://www.z80.info/decoding.htm

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"

	"github.com/blackchip-org/pac8/bits"
)

var tableR = map[int]string{
	0: "B",
	1: "C",
	2: "D",
	3: "E",
	4: "H",
	5: "L",
	6: "IndirectHL",
	7: "A",
}

var rp = map[int]string{
	0: "BC",
	1: "DE",
	2: "HL",
	3: "SP",
}

func process(op uint8) string {
	x := bits.Slice(op, 6, 7)
	//y := bits.Slice(op, 3, 5)
	z := bits.Slice(op, 0, 2)
	p := int(bits.Slice(op, 4, 5))
	q := bits.Slice(op, 3, 3)

	if x == 0 {
		if z == 1 {
			if q == 0 {
				return fmt.Sprintf("ld16(c, c.store%v, c.loadImm16)", rp[p])
			}
		}
		if z == 2 {
			if q == 0 {
				if p == 0 {
					return fmt.Sprintf("ld(c, c.storeIndBC, c.loadA)")
				}
				if p == 1 {
					return fmt.Sprintf("ld(c, c.storeIndDE, c.loadA)")
				}
				if p == 2 {
					return fmt.Sprintf("ld16(c, c.store16IndImm, c.loadHL)")
				}
				if p == 3 {
					return fmt.Sprintf("ld(c, c.storeIndImm, c.loadA)")
				}
			}
			if q == 1 {
				if p == 0 {
					return fmt.Sprintf("ld(c, c.storeA, c.loadIndBC)")
				}
				if p == 1 {
					return fmt.Sprintf("ld(c, c.storeA, c.loadIndDE)")
				}
				if p == 2 {
					return fmt.Sprintf("ld16(c, c.storeHL, c.load16IndImm)")
				}
				if p == 3 {
					return fmt.Sprintf("ld(c, c.storeA, c.loadIndImm)")
				}
			}
		}
	}
	return ""
}

func main() {
	var out bytes.Buffer

	out.WriteString(`
// Code generated by gen/z80/ops. DO NOT EDIT.

package z80

var ops = map[uint8]func(c *CPU){
`)
	for i := 0; i < 0x100; i++ {
		fn := process(uint8(i))
		if fn == "" {
			fn = "c.skip = true"
		}
		line := fmt.Sprintf("0x%02x: func(c *CPU){%v},\n", i, fn)
		out.WriteString(line)
	}
	out.WriteString("}\n")

	err := ioutil.WriteFile("../../../cpu/z80/ops.go", out.Bytes(), 0644)
	if err != nil {
		fmt.Printf("unable to write file: %v", err)
		os.Exit(1)
	}
}
